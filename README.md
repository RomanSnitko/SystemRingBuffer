# System Ring Buffer (C++20)

Кольцевой буфер на C++, использующий виртуальную памяти для обеспечения линейного доступа к данным даже на границах буфера.

## В чем уникальность?

Обычные кольцевые буферы при достижении конца массива вынуждены:
1. Либо проверять границы при каждой записи (`if (pos > end)`).
2. Либо разбивать одну операцию записи на две (`memcpy` в конец + `memcpy` в начало).

Данная реализация полностью убирает ветвление при операциях чтения и записи. Это достигается за счет использования механизмов ядра Linux (подсистема виртуальной памяти).

## Как это работает?

Основная идея заключается в том, чтобы обмануть процессор, настроив таблицу страниц виртуальной памяти так, чтобы два последовательных участка виртуальных адресов указывали на один и тот же блок физической памяти (RAM).

### Физическая реальность:
Выделяется ровно один блок памяти размером `N` (кратно размеру страницы ОС).

### Виртуальная иллюзия:
В конструкторе мы настраиваем отображение так:
* Виртуальный диапазон A (от 0 до N): указывает на физический блок.
* Виртуальный диапазон B (от N до 2N): указывает на тот же самый физический блок.

Результат: когда данные записываются на границе первого диапазона и выходят за его пределы, они бесшовно продолжаются во втором диапазоне. Но благодаря нашей адресной связности, аппаратура процессора (MMU) физически записывает эти байты в начало первого блока.

## Визуализация:
```
Виртуальная память:  [ Блок Данных (N) ][ Блок Данных (N) ]
                            |                  |
                            \________  ________/
                                     \/
Физическая RAM:              [ Блок Данных (N) ]
```

## Реализация (Linux Specific)

Для достижения этого эффекта в конструкторе используются системные вызовы:
1. `memfd_create` — создание анонимного файла в оперативной памяти.
2. `ftruncate` — задание физического размера буфера.
3. `mmap` (Reservation) — бронирование непрерывного участка в виртуальной памяти размером `2N`.
4. `mmap` (Mapping) — двойное отображение файла в забронированный участок с флагом `MAP_FIXED`.

## Особенности кода

* C++20 Concepts: oграничение типов через `std::is_trivially_copyable_v<T>`. Мы работаем с сырой памятью, поэтому типы должны быть безопасно копируемыми через `memcpy`.
* Modern C++: использование `std::span` для эффективной передачи данных без лишних копирований.
* Zero-Branching: функции `write` и `read` не содержат условий проверки «разрыва» кольца. Один вызов `memcpy` делает всё.
* RAII: полное управление ресурсами (дескрипторы файлов и маппинги) очищаются автоматически в деструкторе.
